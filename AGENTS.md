# AGENTS.md

## 1. Introduction

### 1.1. Purpose
Define a controllable, observable multi-tool agent for graph manipulation using LangGraph and LangChain, with progressive context disclosure, intelligent escalation, strict contracts, and production-grade instrumentation via Langfuse.

### 1.2. Objectives
- Build a stateful agent that translates natural language into safe, idempotent graph operations and graph-aware answers.
- Keep orchestration outside the LLM via a state graph and typed tools, enabling determinism, recoverability, and auditing.
- Add first-class observability with Langfuse traces/spans, and enforce high-quality docstrings across the codebase.

## 2. Architecture Overview

### 2.1. Tech Stack
- **Orchestration**: LangGraph (state machine, conditional edges, Command, checkpointer, interrupts).
- **LLM & Tools**: LangChain (structured outputs, tool calling).
- **Graph DB**: Neo4j (MERGE-based idempotent writes), optional GraphCypher QA.
- **Observability**: Langfuse (traces, spans, prompt management, evaluations).

### 2.2. State Schema
The agent's state is the single source of truth for control flow. It is a typed dictionary with a minimal shape to prevent unbounded growth.

- **Fields**: `goal`, `plan`, `progress`, `failures`, `messages`, `artifacts`, and private channels for inter-node data (`_tool_signature`, `_error_context`, etc.).
- **Snippet (`puntini/orchestration/state.py`)**:
  ```python
  class State(TypedDict):
      goal: str
      plan: list[str]
      progress: list[str]
      failures: list[dict]
      messages: list[Any]
      # ... and other fields
  ```

### 2.3. Flow Control and Recovery
- **Conditional Edges**: The graph uses conditional edges to route the agent based on the state.
- **`Command` Object**: Nodes like `escalate` can return a `Command` object for atomic `update` and `goto` semantics.
- **Checkpointer**: The agent uses a checkpointer for durable memory and deterministic resume after an interrupt or crash.
- **Interrupts**: The `escalate` node serves as an interrupt gate for human-in-the-loop interaction.

## 3. Graph Flow

The agent's logic is implemented as a state graph. For a visual representation and detailed description of the graph flow, please refer to [GRAPH.md](GRAPH.md).

### 3.1. Nodes and Responsibilities
- **`parse_goal`**: Extracts the goal, constraints, and domain hints from the user's input into a structured `GoalSpec` object.
- **`plan_step`**: Breaks down a complex goal into a series of smaller, executable steps, each with a `ToolSignature`.
- **`route_tool`**: Validates the `ToolSignature` and ensures the requested tool is available and has valid arguments.
- **`call_tool`**: Executes the selected tool with the validated arguments.
- **`evaluate`**: Evaluates the result of the tool execution and decides whether to continue, retry, or escalate.
- **`diagnose`**: Classifies failures (e.g., "identical", "random", "systematic") and chooses a remediation strategy.
- **`escalate`**: Interrupts the execution for human input when the agent is stuck.
- **`answer`**: Synthesizes the final answer and summarizes the work done by the agent.

## 4. Core Concepts

### 4.1. Progressive Context Disclosure
To manage the context provided to the LLM efficiently, the agent uses a progressive disclosure strategy:
- **Attempt 1**: Pass only the current task and minimal tool signature hints.
- **Attempt 2**: If an error occurs, add the structured error and just enough payload to disambiguate.
- **Attempt 3**: Add selected history and a concise plan recap.
- **Final**: Escalate with a clear summary and options for the user.

### 4.2. Interfaces First
The codebase is designed with an "Interfaces First" approach to ensure modularity and testability. Minimal, testable contracts are defined in the `puntini/interfaces/` directory for components like `GraphStore`, `ContextManager`, and `ToolRegistry`.

### 4.3. Data Models
All domain entities inherit from a `BaseEntity` model that injects a code-controlled UUIDv4 `id` and timestamps. This ensures that identifiers are not generated by the LLM and remain immutable.

## 5. Implementation Details

### 5.1. LLM and Logging Configuration
- **LLM**: The agent supports multiple LLM providers, configured in `puntini/settings.py` and `config.json`.
- **Logging**: The logging module is in `puntini/logging/` and is also configured in `puntini/settings.py`.

### 5.2. Factories
The agent uses factories to instantiate concrete implementations of the interfaces from a configuration. This allows for easy swapping of components (e.g., using an in-memory graph for testing and Neo4j for production).
- `make_graph_store`
- `make_context_manager`
- `make_tool_registry`
- `make_tracer`
- `make_agent`

### 5.3. Tools and Contracts
- **Tools**: The agent has access to a set of tools for graph manipulation, such as `add_node`, `add_edge`, and `query_graph`.
- **Contracts**: Tools have a clear contract, with their inputs and outputs defined by Pydantic schemas.

### 5.4. Neo4j Semantics
- **Idempotence**: The Neo4j implementation uses `MERGE` with stable natural keys to ensure that write operations are idempotent, even on retries.
- **Encapsulation**: Cypher queries are encapsulated within the `GraphStore` and are not constructed by the LLM directly.

### 5.5. Instrumentation with Langfuse
The agent is instrumented with Langfuse for observability:
- Each run of the state graph is traced.
- Tool calls are wrapped in child spans.
- Inputs, outputs, and key decision points are recorded.

## 6. Development and Operations

### 6.1. Directory Layout
The project follows a structured directory layout, with clear separation of concerns. For details, see the `Directory Layout` section in the original `AGENTS.md`.

### 6.2. Build Status and Next Steps
- **Current Status**: The core graph skeleton is implemented, but the logic within some nodes (`evaluate`, `diagnose`, `escalate`, `answer`) is still placeholder.
- **Next Steps**:
    - Implement the concrete logic for the placeholder nodes.
    - Implement the Neo4j `GraphStore` and the full `ContextManager` policies.

### 6.3. Coding and Testing Standards
- **Docstrings**: All public APIs must have comprehensive docstrings (Google-style or NumPy-style).
- **Testing**: The project includes unit, integration, and end-to-end tests. For details on the testing strategy, see the `Testing and Quality Gates` section in the original `AGENTS.md`.

## 7. Future Extensions
- GraphRAG and hierarchical summaries for large corpora.
- Auto-tuning of disclosure policies and retry budgets.
- Scorecards and dashboards in Langfuse for error taxonomy and tool helpfulness.
